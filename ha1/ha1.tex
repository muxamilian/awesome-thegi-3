\documentclass[a4paper,10pt]{scrartcl}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[german]{babel}
\setlength{\parindent}{0cm}
\usepackage{setspace}
\usepackage{mathpazo}
\usepackage{graphicx}
\usepackage{wasysym} 
\usepackage{booktabs}
\usepackage{verbatim}
\usepackage{pst-all}
\usepackage{enumerate}
\usepackage{pstricks}
\usepackage[a4paper,
left=1.8cm, right=1.8cm,
top=2.0cm, bottom=2.0cm]{geometry}
\newcommand{\N}{\mathbb{N}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\ts}{\textsf}

\usepackage{tabularx}

\newcolumntype{L}[1]{>{\raggedright\arraybackslash}p{#1}}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash}p{#1}}


\author{}

\begin{document}

\begin{center}
\Large{Theoretische Grundlagen der Informatik 3: Hausaufgabenabgabe 1} \\
\large{Tutorium: Sebastian , Mi 14.00 - 16.00 Uhr}
\end{center}
\begin{tabbing}
Tom Nick \hspace{2cm}\= - 340528\\
Maximillian Bachl \> - 341455 \\
Marius Liwotto\> -  341051
\end{tabbing}

\section{Aufgabe}
\textbf{T} - Tobi kommt $\mid$
\textbf{C} - Christoph kommt $\mid$
\textbf{S} - Sebastian kommt $\mid$
\textbf{V} - Viktor kommt $\mid$
\textbf{F} - Friederike kommt
\begin{align*}
(T \to C \land S) \land
(C \lor V) \land
(S \to \lnot F) \land
(\lnot V) \land
(\lnot T \to \lnot C) &\leftrightarrow \\
(\lnot T \lor (C \land S)) \land
(C \lor V) \land
(\lnot S \lor \lnot F) \land
(\lnot V) \land
(T \lor \lnot C) &\leftrightarrow \\
(\lnot T \lor C) \land (\lnot T \lor S) \land
C \land \lnot V \land
(\lnot S \lor \lnot F) \land
(T \lor \lnot C) &\leftrightarrow \\
C \land (\lnot T \lor S) \land
\lnot V \land
(\lnot S \lor \lnot F) \land
(T \lor \lnot C) &\leftrightarrow \\
C \land (\lnot T \lor S) \land
\lnot V \land
(\lnot S \lor \lnot F) \land
T &\leftrightarrow \\
C \land S \land
\lnot V \land
\lnot F \land
T
\end{align*}
Also kommen: Christopher, Sebastian und Tobi. Viktor und Frederike werden nicht kommen.
\section{Aufgabe}

\begin{enumerate}[(i)]
\item Ist nicht erfüllbar
\begin{align*}
\lnot(X \to (Y \to X)) &\leftrightarrow \\
\lnot(\lnot X \lor (\lnot Y \lor X)) &\leftrightarrow \\
\lnot\top &\leftrightarrow \\
\bot
\end{align*}

\item Ist erfüllbar
\begin{align*}
(X \land (Y \to \lnot X)) \to Y &\leftrightarrow \\
\lnot(X \land (\lnot Y \lor \lnot X)) \lor Y &\leftrightarrow \\
\lnot(X \land \lnot Y) \lor Y &\leftrightarrow \\
\lnot X \lor Y \lor Y &\leftrightarrow \\
\lnot X \lor Y
\end{align*}

\item Ist erfüllbar
\begin{align*}
(\lnot X \to (X \land Y)) \to (Y \to X) &\leftrightarrow \\
\lnot (X \lor (X \land Y)) \lor \lnot(Y \lor X) &\leftrightarrow\\
\lnot ((X \lor (X \land Y)) \land (Y \lor X)) &\leftrightarrow\\
\lnot (X \land (Y \lor X)) &\leftrightarrow\\
\lnot (X \land (Y \lor X)) &\leftrightarrow\\
\lnot X
\end{align*}

\item Ist erfüllbar

\begin{align*}
(X \lor Y) \to (X \land Y) &\leftrightarrow\\
\lnot(X \lor Y) \lor (X \land Y) &\leftrightarrow\\
(\lnot X \land \lnot Y) \lor (X \land Y) &\leftrightarrow\\
(X \leftrightarrow Y)
\end{align*}

\item Ist eine Tautologie

\begin{align*}
(X \land Y ) \to (X \lor Y) &\leftrightarrow \\
\lnot (X \land Y ) \lor (X \lor Y) &\leftrightarrow\\
\lnot X \lor \lnot Y \lor (X \lor Y) &\leftrightarrow\\
\lnot X \lor \lnot Y \lor (X \lor Y) &\leftrightarrow\\
\lnot X \lor \lnot Y \lor X \lor Y &\leftrightarrow\\
\top
\end{align*}
\end{enumerate}

\section{Aufgabe}
%$$\phi_i\mathsf{(a_{n-1},...,a_0,b_{n-1},...,b_0)} \rightarrow 
%\begin{cases} \top ,& \textrm{falls } \mathsf{(concat(a_{n-1},...,a_0) + concat(b_{n-1},...,b_0))_i}  = 1 \\ \bot,  & \textrm{sonst }\end{cases}$$
Sei $\phi_i$ induktiv definiert als: 
\begin{align*}
\phi_0(a_{n-1},...,a_0,b_{n-1},...,b_0) &= \lnot(a_0 \leftrightarrow b_0) \\
\psi_0(a_{n-1},...,a_0,b_{n-1},...,b_0) &= a_0 \land b_0\\
\phi_{i+1}(a_{n-1},...,a_0,b_{n-1},...,b_0) &= (\lnot a_{i+1} \land \lnot b_{i+1} \land \psi_i) \lor  (\lnot a_{i+1} \land b_{i+1} \land \lnot \psi_i)  \lor (a_{i+1} \land \lnot b_{i+1} \land \lnot \psi_i)  \lor (a_{i+1} \land  b_{i+1} \land \psi_i)  \\
\psi_{i+1}(a_{n-1},...,a_0,b_{n-1},...,b_0) &= (a_{i+1} \land b_{i+1}) \lor (a_{i+1} \land \psi_i) \lor (b_{i+1} \land \psi_i)
\end{align*}

\section{Aufgabe}
% Irgendwas mit der Disjunktive Normalform würde ich probieren. Die war in der Vorlesung und dürfen wir auch benutzen... 
Wie in der Vorlesung gezeigt wurde (Folien S. ) gibt es zu jeder Formel $\phi$ eine äquivalente konjunktive Normalform. Damit diese der Bedingung max-depth = min-depth gerecht wird, bedarf es folgender Konstruktion: \\
$$f(\phi) \rightarrow \begin{cases}f((\psi \land \top) * \xi), & \phi = (\psi * \xi) \land \textrm{ max-depth($\psi$) $<$ max-depth($\xi$)} \land * \in \{ \lor, \land\} \\ f(\psi * (\xi \land \top)), & \phi = (\psi * \xi) \land \textrm{ max-depth($\psi$) $>$ max-depth($\xi$)} \land * \in \{ \lor, \land\}  \\
(f(\psi) * f(\xi)), & \phi = (\psi * \xi) \land \textrm{ max-depth($\psi$) $=$ max-depth($\xi$)} \land * \in \{ \lor, \land\} \\ \phi ,& \phi \in (\textrm{AVar } \cup \lnot\textrm{AVar } \cup \{\top, \bot  \})\end{cases} $$ $$ \textrm{wobei $\lnot$AVar definiert ist als die Menge der negierten Variablen von AVar} $$


Sei zu beweisen, dass diese Konstruktion hält was sie verspricht. 

\begin{itemize}
\item[\textbf{IA}]  $\phi \in (\textrm{AVar }  \cup \{\top, \bot  \}) \Rightarrow f(\phi) = \phi \Rightarrow$ max-depth($f(\phi)$) = 0 = min-depth($f(\phi)$) \\
 $\phi \in \lnot\textrm{AVar } \Rightarrow$ $f(\phi) = \phi \Rightarrow$ max-depth($f(\phi)$) = 1 = min-depth($f(\phi)$) 
\item[\textbf{IV}] Sei $\psi$ eine Formel, wobei max-depth($f(\psi)$) =  min-depth($f(\psi)$) und  \\ Sei $\xi$ eine Formel, wobei max-depth($f(\xi)$) = min-depth($f(\xi)$)
\item[\textbf{IS}] Zu Zeigen ist, dass für die Termgrösse n+1 das ganze noch gilt: $f(\psi  * \xi)$ \\
\textbf{Fallunterscheidung über $f(\psi  * \xi)$}
\begin{itemize}
\item $\textrm{ max-depth($\psi$) $<$ max-depth($\xi$)} \land * \in \{ \lor, \land\}$ \\
$f(\psi  * \xi) = f((\psi \land \top)  * \xi) = ... = f((...(\psi \land \top) ...) * \xi)$ \\
Es werden zu $\psi$ so lange $\land \top$ hinzugefügt bis max-depth der linken Seite = max-depth der rechten Seite. Jetzt kommt die Magie der Rekursion und die Funktion wird auf die Unterfunktionen aufgerufen: \\
$(f(...(\psi \land \top) ... \land \top)) * f(\xi)) = (f(...(\psi \land \top) ... \land (\top \land \top)) * f(\xi)) = ... $ \\
Durch die rekursiven Aufrufe wird der Term und alle Subterme tiefensymmetrisch.
Wegen der \textbf{IV} ist damit auch min-depth($f(\psi * \xi)$) = max-depth($f(\psi * \xi)$)
\item $\textrm{ max-depth($\psi$) $>$ max-depth($\xi$)} \land * \in \{ \lor, \land\}$ \\
analog
\item  $\textrm{ max-depth($\psi$) $=$ max-depth($\xi$)} \land * \in \{ \lor, \land\}$ \\
Da $\textrm{ max-depth($\psi$) $=$ max-depth($\xi$)} $ gilt per Transitivität und der \textbf{IV} dieser Fall.
\end{itemize}


\end{itemize}

\end{document}








